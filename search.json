[
  {
    "objectID": "mean.html",
    "href": "mean.html",
    "title": "Mean Baselines",
    "section": "",
    "text": "library(neonstore)\nlibrary(neon4cast) # remotes::install_github(\"eco4cast/neon4cast\", dep=TRUE)\nlibrary(tidyverse)\nlibrary(tsibble)\nlibrary(lubridate)\nlibrary(fable)"
  },
  {
    "objectID": "mean.html#access-target-data",
    "href": "mean.html#access-target-data",
    "title": "Mean Baselines",
    "section": "Access Target Data",
    "text": "Access Target Data\n\ntargets &lt;-\n  \"https://data.ecoforecast.org/neon4cast-targets/aquatics/aquatics-targets.csv.gz\" |&gt; \n  read_csv(show_col_types = FALSE) \n\ntargets_ts &lt;- targets |&gt; \n  as_tsibble(index = datetime, key = c(variable,site_id))\n\n\npast &lt;-  targets_ts |&gt; filter(datetime &lt; forecast_date) |&gt;\n  pivot_wider(names_from=\"variable\", values_from=\"observation\")"
  },
  {
    "objectID": "mean.html#compute-a-forecast",
    "href": "mean.html#compute-a-forecast",
    "title": "Mean Baselines",
    "section": "Compute a forecast",
    "text": "Compute a forecast\n\n## Compute a simple mean/sd model per site... obviously silly given huge seasonal aspect\nnull_temperature &lt;- past  |&gt; \n  model(null = MEAN(temperature)) |&gt;\n  forecast(h = \"1 year\")\n\nnull_oxygen &lt;- past  |&gt;\n  model(null = MEAN(oxygen)) |&gt;\n  forecast(h = \"1 year\")"
  },
  {
    "objectID": "mean.html#visualize-the-forecast",
    "href": "mean.html#visualize-the-forecast",
    "title": "Mean Baselines",
    "section": "Visualize the forecast",
    "text": "Visualize the forecast\n\nfirst4 &lt;- unique(null_temperature$site_id)[1:4]\n\nnull_temperature |&gt; filter(site_id %in% first4)  |&gt; \n  autoplot(past) + ggtitle(\"temperature\")\n\n\n\nnull_oxygen |&gt; filter(site_id %in% first4)  |&gt; \n  autoplot(past) + ggtitle(\"oxygen\")"
  },
  {
    "objectID": "mean.html#efi-formatting",
    "href": "mean.html#efi-formatting",
    "title": "Mean Baselines",
    "section": "EFI Formatting",
    "text": "EFI Formatting\nEFI requires a flat-file format for forecasts that avoids the use of complex list columns.\nTo convey uncertainty, forecasts must be expressed either by giving mean and standard deviation (for predictions that are normally distributed) or must express forecasts as an ensemble of replicate draws from forecast distribution. The helper function efi_format() handles this transformation.\n\nforecast &lt;- \n  bind_rows(efi_format(null_temperature), \n            efi_format(null_oxygen)) |&gt;\n  mutate(reference_datetime = forecast_date)\n\n\nscores &lt;- neon4cast::score(forecast, targets)\n\n\nscores |&gt; \n  score4cast::include_horizon(allow_difftime = TRUE) |&gt; \n  group_by(variable) |&gt;\n  summarise(crps = mean(crps, na.rm=TRUE), \n            logs = mean(logs, na.rm=TRUE))\n\n\n\n  \n\n\n\n\nforecast_file &lt;- glue::glue(\"{theme}-{date}-{team}.csv.gz\",\n                            theme = \"aquatics\", \n                            date=forecast_date,\n                            team = \"cb_f1\")\nwrite_csv(forecast, forecast_file)\n\n\nneon4cast::forecast_output_validator(forecast_file)\n\n[1] TRUE\n\n\n\nsubmit(forecast_file)\n\n\nunlink(forecast_file)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This repository hosts the code for some submissions to the EFI NEON Forecasting Challenge.\nThese forecasts are made for mostly exploratory and educational purposes, emphasizing simplicity and the illustration of various forecasting concepts over technical accuracy. This repository includes a range of forecasts of varying complexity. Each forecast focuses on introducing a different strategy into the modeling. An earnest attempt to produce the best forecast would draw on several of these approaches after evaluating the relative performance of each. All forecasts here are probabilistic: representing uncertainty is an essential component of forecasting and a crucial element of the EFI challenge."
  },
  {
    "objectID": "weather.html",
    "href": "weather.html",
    "title": "A weather-based forecast",
    "section": "",
    "text": "library(neonstore)\nlibrary(neon4cast) # remotes::install_github(\"eco4cast/neon4cast\", dep=TRUE)\nlibrary(tidyverse)\nlibrary(tsibble)\nlibrary(lubridate)\nlibrary(fable)\nlibrary(glue)\nforecast_date &lt;-  Sys.Date() - days(35)"
  },
  {
    "objectID": "weather.html#access-target-data",
    "href": "weather.html#access-target-data",
    "title": "A weather-based forecast",
    "section": "Access Target Data",
    "text": "Access Target Data\nThe target data is simply a CSV file. We convert this to a time-series table, or tsibble, by indicating time is indexed by the datetime column, with unique values for each combination of variable and site_id.\n\ntargets &lt;-\n  glue(\"https://data.ecoforecast.org/neon4cast-targets/\",\n       \"{theme}/{theme}-targets.csv.gz\", theme=\"aquatics\") |&gt; \n  read_csv(show_col_types = FALSE) \n\ntargets_ts &lt;- targets |&gt; \n  pivot_wider(names_from=\"variable\", values_from=\"observation\") |&gt;\n  as_tsibble(index = datetime, key = site_id)\n\nfable requires variables be given as independent columns, so we use pivot_wider(). For illustrative purposes, we will filter out observations more recent than “forecast date”. In a production forecast, obviously this is just the current date and we use all available data, but then we have to wait a few days before we have new observations to score.\n\npast &lt;-  \n  targets_ts |&gt; \n  filter(datetime &lt; forecast_date)"
  },
  {
    "objectID": "weather.html#site-data",
    "href": "weather.html#site-data",
    "title": "A weather-based forecast",
    "section": "Site data",
    "text": "Site data\n\nsite_data &lt;- \n  glue(\"https://raw.githubusercontent.com/eco4cast/neon4cast-targets/\",\n                            \"main/NEON_Field_Site_Metadata_20220412.csv\") |&gt;\n  read_csv() |&gt; \n  filter(aquatics == 1) |&gt;\n  select(site_id = field_site_id, elevation = field_mean_elevation_m)"
  },
  {
    "objectID": "weather.html#access-weather-data",
    "href": "weather.html#access-weather-data",
    "title": "A weather-based forecast",
    "section": "Access weather data",
    "text": "Access weather data\nWe will use downscaled snapshots of NOAA GEFS forecasts at NEON sites. Note that historical meteorology goes in the past data, while forecasted meteorology is passed in as new_data to the forecast method.\nWe can use actual NEON weather measurements or NOAA downscaled forecasts sources for historical, past observations. Note that using NOAA’s historical zero-horizon forecast instead of ground-truth measurements can actually be more accurate calibration if future new_data forecasts are also coming from NOAA predictions. (Alternatively, we can merely use historical average seasonal measurements as our long-term ‘forecast’).\n\nsites &lt;- unique(past$site_id)\n\n\nhistory &lt;- \n  noaa_stage3() |&gt;\n  mutate(date = lubridate::as_date(datetime)) |&gt;\n  group_by(site_id, date, variable) |&gt;\n  summarise(mean = mean(prediction, na.rm=TRUE),\n            .groups = \"drop\") |&gt;\n  filter(site_id %in% sites,\n         variable %in% c(\"air_temperature\")) |&gt;\n  collect() |&gt;\n  pivot_wider(c(site_id, date), names_from=\"variable\", values_from = \"mean\") |&gt;\n  mutate(air_temperature = air_temperature -273) |&gt;\n  rename(datetime = date)\n\nJoin the historical NOAA record of air_temperature by site and datetime\n\npast2 &lt;- left_join(past, as_tsibble(history, datetime, key=site_id) ) |&gt; \n  select(temperature, air_temperature, oxygen)  |&gt; \n  left_join(site_data)\n\n\nfuture &lt;- noaa_stage2() |&gt; \n  filter(reference_datetime == lubridate::as_datetime(forecast_date),\n         variable %in% c(\"air_temperature\"),\n         site_id %in% sites) |&gt;\n  mutate(date = lubridate::as_date(datetime)) |&gt;\n  group_by(site_id, date, variable) |&gt;\n  summarise(mean = mean(prediction, na.rm=TRUE),\n            .groups = \"drop\") |&gt;\n  collect() |&gt;\n  pivot_wider(c(site_id, date), \n              names_from=\"variable\", \n              values_from = \"mean\") |&gt;\n  mutate(air_temperature = air_temperature -273)  |&gt;\n  rename(datetime = date)"
  },
  {
    "objectID": "weather.html#compute-a-forecast",
    "href": "weather.html#compute-a-forecast",
    "title": "A weather-based forecast",
    "section": "Compute a forecast",
    "text": "Compute a forecast\n\nnew_data &lt;- future |&gt; as_tsibble(datetime, key=site_id) |&gt; left_join(site_data)\n\n\nfc_temperature &lt;- \n  past2  |&gt; \n  select(temperature, air_temperature) |&gt;\n  drop_na() |&gt; \n  fill_gaps() |&gt;\n  model(tslm = TSLM(temperature ~ air_temperature)) |&gt;\n  forecast(new_data = new_data)\n\nWe can use the mean forecast temperature to drive the oxygen forecast\n\nnew_data2 &lt;- left_join(new_data, fc_temperature) |&gt; \n  select(site_id, datetime, air_temperature, temperature = .mean)\n\n\nfc_oxygen &lt;- past2  |&gt; drop_na() |&gt; fill_gaps() |&gt;\n  model(tslm = TSLM(oxygen ~ temperature  ) ) |&gt;\n  forecast(new_data = new_data2) |&gt;\n  select(site_id, datetime, oxygen, .model, .mean)"
  },
  {
    "objectID": "weather.html#visualize-the-forecast",
    "href": "weather.html#visualize-the-forecast",
    "title": "A weather-based forecast",
    "section": "Visualize the forecast",
    "text": "Visualize the forecast\n\nfirst4 &lt;- unique(fc_temperature$site_id)[1:6]\ncutoff &lt;- forecast_date - months(3)\nhistorical &lt;- targets_ts |&gt; filter(datetime &gt; cutoff)\n\nfc_temperature |&gt; filter(site_id %in% first4)  |&gt; \n  autoplot(historical) + ggtitle(\"temperature\")\n\n\n\nfc_oxygen |&gt; filter(site_id %in% first4, datetime &gt; cutoff)  |&gt; \n  autoplot(historical) + ggtitle(\"oxygen\")"
  },
  {
    "objectID": "weather.html#efi-formatting",
    "href": "weather.html#efi-formatting",
    "title": "A weather-based forecast",
    "section": "EFI Formatting",
    "text": "EFI Formatting\nEFI requires a flat-file format for forecasts that avoids the use of complex list columns. To convey uncertainty, forecasts must be expressed either as a parametric distribution (e.g. for predictions that are normally distributed) or must express forecasts as an ensemble of replicate draws from forecast distribution. The helper function efi_format() handles this transformation.\n\nfc_temperature &lt;- fc_temperature |&gt; select(-air_temperature, -elevation)\n\nforecast &lt;- bind_rows(efi_format(fc_temperature), \n                      efi_format(fc_oxygen))  |&gt;\n            mutate(reference_datetime = forecast_date)\n\n\nscores &lt;- score(forecast, targets)\nfable_score &lt;- scores |&gt; \n  score4cast::include_horizon(allow_difftime = TRUE) |&gt; \n  group_by(variable) |&gt;\n  summarise(crps = mean(crps, na.rm=TRUE), \n            logs = mean(logs, na.rm=TRUE))\nfable_score\n\n# A tibble: 2 × 3\n  variable     crps  logs\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 oxygen      0.784  4.29\n2 temperature 2.46   3.35\n\n\n\nforecast_file &lt;- glue::glue(\"{theme}-{date}-{team}.csv.gz\",\n                            theme = \"aquatics\", \n                            date=forecast_date,\n                            team = \"cb_weather\")\nwrite_csv(forecast, forecast_file)\n\n\nneon4cast::forecast_output_validator(forecast_file)\n\n[1] TRUE\n\n\n\nsubmit(forecast_file)\n\n\nunlink(forecast_file)"
  }
]