[
  {
    "objectID": "weather.html",
    "href": "weather.html",
    "title": "A weather-based forecast",
    "section": "",
    "text": "library(neonstore)\nlibrary(neon4cast) # remotes::install_github(\"eco4cast/neon4cast\", dep=TRUE)\n\nRegistered S3 methods overwritten by 'readr':\n  method                    from \n  as.data.frame.spec_tbl_df vroom\n  as_tibble.spec_tbl_df     vroom\n  format.col_spec           vroom\n  print.col_spec            vroom\n  print.collector           vroom\n  print.date_names          vroom\n  print.locale              vroom\n  str.col_spec              vroom\n\nlibrary(tidyverse)\n\n── Attaching packages\n───────────────────────────────────────\ntidyverse 1.3.2 ──\n\n\n✔ ggplot2 3.4.0      ✔ purrr   1.0.0 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(tsibble)\n\n\nAttaching package: 'tsibble'\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, union\n\nlibrary(lubridate)\n\nLoading required package: timechange\n\nAttaching package: 'lubridate'\n\nThe following object is masked from 'package:tsibble':\n\n    interval\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(fable)\n\nLoading required package: fabletools\n\nlibrary(glue)\nknitr::opts_chunk$set(message=FALSE, eval=FALSE) # eval=FALSE to omit running"
  },
  {
    "objectID": "weather.html#access-target-data",
    "href": "weather.html#access-target-data",
    "title": "A weather-based forecast",
    "section": "Access Target Data",
    "text": "Access Target Data\nThe target data is simply a CSV file. We convert this to a time-series table, or tsibble, by indicating time is indexed by the datetime column, with unique values for each combination of variable and site_id.\n\ntargets <-\n  glue(\"https://data.ecoforecast.org/neon4cast-targets/\",\n       \"{theme}/{theme}-targets.csv.gz\", theme=\"aquatics\") |> \n  read_csv(show_col_types = FALSE) \n\ntargets_ts <- targets |> \n  as_tsibble(index = datetime, key = c(variable,site_id))\n\nfable requires variables be given as independent columns, so we use pivot_wider(). For illustrative purposes, we will filter out observations more recent than “forecast date”. In a production forecast, obviously this is just the current date and we use all available data, but then we have to wait a few days before we have new observations to score.\n\npast <-  targets_ts |> \n  filter(datetime < forecast_date) |>\n  pivot_wider(names_from=\"variable\", values_from=\"observation\")"
  },
  {
    "objectID": "weather.html#access-weather-data",
    "href": "weather.html#access-weather-data",
    "title": "A weather-based forecast",
    "section": "Access weather data",
    "text": "Access weather data\nWe will use downscaled snapshots of NOAA GEFS forecasts at NEON sites. Note that historical meteorology goes in the past data, while forecasted meteorology is passed in as new_data to the forecast method.\nWe can use actual NEON weather measurements or NOAA downscaled forecasts sources for historical, past observations. Note that using NOAA’s historical zero-horizon forecast instead of ground-truth measurements can actually be more accurate calibration if future new_data forecasts are also coming from NOAA predictions. (Alternatively, we can merely use historical average seasonal measurements as our long-term ‘forecast’).\n\nsites <- unique(past$site_id)\n\n# peek at the distinct variable names\n#  noaa_stage3() |> distinct(variable) |> collect()\n# noaa_stage1()  |> distinct(variable) |> collect()\n\n# average over ensembles.  A little slow\nhistorical <- noaa_stage3() |> \n  filter(site_id %in% sites,\n         variable %in% c(\"air_temperature\", \"precipitation_flux\")) |>\n  mutate(date = lubridate::as_date(datetime)) |>\n  group_by(site_id, date, variable) |>\n  summarise(mean = mean(prediction),\n            min = min(prediction),\n            max = max(prediction)) |>\n  collect()\n\n\nfuture <- noaa_stage1() |>\n  filter(site_id %in% sites,\n         variable %in% c(\"TMP\", \"PRECP\")) |>\n  mutate(date = lubridate::as_date(datetime)) |>\n  group_by(site_id, date, variable) |>\n  summarise(mean = mean(prediction),\n            min = min(prediction),\n            max = max(prediction)) |>\n  collect()\n\n\nhistorical_w <- historical |>\n  pivot_wider(names_from=\"variable\", values_from=\"prediction\") |> \n  mutate(air_temperature = air_temperature - 273)\n\n\nfuture_w <- future |> \n   pivot_wider(names_from=\"variable\", values_from=\"prediction\") |>\n   rename(air_temperature = TMP,\n          precip = )"
  },
  {
    "objectID": "weather.html#compute-a-forecast",
    "href": "weather.html#compute-a-forecast",
    "title": "A weather-based forecast",
    "section": "Compute a forecast",
    "text": "Compute a forecast\n\nnull_temperature <- past  |> \n  model(null = TSLM(temperature ~ air_temperature)) |>\n  forecast(h = \"1 year\")\n\nnull_oxygen <- past  |>\n  model(null = TSLM(oxygen ~ temperature)) |>\n  forecast(h = \"1 year\")"
  },
  {
    "objectID": "weather.html#visualize-the-forecast",
    "href": "weather.html#visualize-the-forecast",
    "title": "A weather-based forecast",
    "section": "Visualize the forecast",
    "text": "Visualize the forecast\n\nfirst4 <- unique(null_temperature$site_id)[1:4]\n\nnull_temperature |> filter(site_id %in% first4)  |> \n  autoplot(past) + ggtitle(\"temperature\")\nnull_oxygen |> filter(site_id %in% first4)  |> \n  autoplot(past) + ggtitle(\"oxygen\")"
  },
  {
    "objectID": "weather.html#efi-formatting",
    "href": "weather.html#efi-formatting",
    "title": "A weather-based forecast",
    "section": "EFI Formatting",
    "text": "EFI Formatting\nEFI requires a flat-file format for forecasts that avoids the use of complex list columns.\nTo convey uncertainty, forecasts must be expressed either by giving mean and standard deviation (for predictions that are normally distributed) or must express forecasts as an ensemble of replicate draws from forecast distribution. The helper function efi_format() handles this transformation.\n\nforecast <- bind_rows(efi_format(null_temperature), \n                      efi_format(null_oxygen)) \n\n\nscores <- neon4cast::score(forecast, targets)\n\nscores |> filter(!is.na(observation))\n\n\nforecast_file <- glue::glue(\"{theme}-{date}-{team}.csv.gz\",\n                            theme = \"aquatics\", \n                            date=forecast_date,\n                            team = \"cb_f1\")\nwrite_csv(forecast, forecast_file)\n\n\nneon4cast::forecast_output_validator(forecast_file)\n\n\nsubmit(forecast_file)\n\n\nunlink(forecast_file)"
  },
  {
    "objectID": "mean.html",
    "href": "mean.html",
    "title": "Mean Baselines",
    "section": "",
    "text": "knitr::opts_chunk$set(message=FALSE)"
  },
  {
    "objectID": "mean.html#access-target-data",
    "href": "mean.html#access-target-data",
    "title": "Mean Baselines",
    "section": "Access Target Data",
    "text": "Access Target Data\n\ntargets <-\n  \"https://data.ecoforecast.org/neon4cast-targets/aquatics/aquatics-targets.csv.gz\" |> \n  read_csv(show_col_types = FALSE) \n\ntargets_ts <- targets |> \n  as_tsibble(index = datetime, key = c(variable,site_id))\n\n\npast <-  targets_ts |> filter(datetime < forecast_date) |>\n  pivot_wider(names_from=\"variable\", values_from=\"observation\")"
  },
  {
    "objectID": "mean.html#compute-a-forecast",
    "href": "mean.html#compute-a-forecast",
    "title": "Mean Baselines",
    "section": "Compute a forecast",
    "text": "Compute a forecast\n\n## Compute a simple mean/sd model per site... obviously silly given huge seasonal aspect\nnull_temperature <- past  |> \n  model(null = MEAN(temperature)) |>\n  forecast(h = \"1 year\")\n\nWarning: 1 error encountered for null\n[1] All observations are missing, a model cannot be estimated without data.\n\nnull_oxygen <- past  |>\n  model(null = MEAN(oxygen)) |>\n  forecast(h = \"1 year\")"
  },
  {
    "objectID": "mean.html#visualize-the-forecast",
    "href": "mean.html#visualize-the-forecast",
    "title": "Mean Baselines",
    "section": "Visualize the forecast",
    "text": "Visualize the forecast\n\nfirst4 <- unique(null_temperature$site_id)[1:4]\n\nnull_temperature |> filter(site_id %in% first4)  |> \n  autoplot(past) + ggtitle(\"temperature\")\n\nWarning: Removed 385 rows containing missing values (`geom_line()`).\n\n\n\n\nnull_oxygen |> filter(site_id %in% first4)  |> \n  autoplot(past) + ggtitle(\"oxygen\")\n\nWarning: Removed 126 rows containing missing values (`geom_line()`)."
  },
  {
    "objectID": "mean.html#efi-formatting",
    "href": "mean.html#efi-formatting",
    "title": "Mean Baselines",
    "section": "EFI Formatting",
    "text": "EFI Formatting\nEFI requires a flat-file format for forecasts that avoids the use of complex list columns.\nTo convey uncertainty, forecasts must be expressed either by giving mean and standard deviation (for predictions that are normally distributed) or must express forecasts as an ensemble of replicate draws from forecast distribution. The helper function efi_format() handles this transformation.\n\nforecast <- bind_rows(efi_format(null_temperature), \n                      efi_format(null_oxygen)) \n\nWarning in drop_degenerate(df): dropping degenerate distributions\n\n\n\nscores <- neon4cast::score(forecast, targets)\n\nscores |> filter(!is.na(observation))\n\n# A tibble: 1,464 × 17\n   model_id site_id datetime   family variable  obser…¹  crps  logs  mean median\n   <chr>    <chr>   <date>     <chr>  <chr>       <dbl> <dbl> <dbl> <dbl>  <dbl>\n 1 null     ARIK    2022-11-25 normal oxygen       6.67 0.669  1.88  7.39   7.39\n 2 null     ARIK    2022-11-25 normal temperat…    3.20 3.98   3.35  9.90   9.90\n 3 null     ARIK    2022-11-26 normal oxygen       6.40 0.739  1.92  7.39   7.39\n 4 null     ARIK    2022-11-26 normal temperat…    4.03 3.51   3.27  9.90   9.90\n 5 null     ARIK    2022-11-27 normal oxygen       5.80 0.974  2.04  7.39   7.39\n 6 null     ARIK    2022-11-27 normal temperat…    5.68 2.74   3.14  9.90   9.90\n 7 null     ARIK    2022-11-28 normal oxygen       6.04 0.869  1.98  7.39   7.39\n 8 null     ARIK    2022-11-28 normal temperat…    4.56 3.24   3.22  9.90   9.90\n 9 null     ARIK    2022-11-29 normal oxygen       6.06 0.863  1.98  7.39   7.39\n10 null     ARIK    2022-11-29 normal temperat…    4.19 3.43   3.25  9.90   9.90\n# … with 1,454 more rows, 7 more variables: sd <dbl>, quantile97.5 <dbl>,\n#   quantile02.5 <dbl>, quantile90 <dbl>, quantile10 <dbl>,\n#   reference_datetime <date>, horizon <dbl>, and abbreviated variable name\n#   ¹​observation\n\n\n\nforecast_file <- glue::glue(\"{theme}-{date}-{team}.csv.gz\",\n                            theme = \"aquatics\", \n                            date=forecast_date,\n                            team = \"cb_f1\")\nwrite_csv(forecast, forecast_file)\n\n\nneon4cast::forecast_output_validator(forecast_file)\n\nWarning: file missing reference_datetime column\n\n\n[1] TRUE\n\n\n\nsubmit(forecast_file)\n\nWarning: file missing reference_datetime column\n\n\n\nunlink(forecast_file)"
  }
]